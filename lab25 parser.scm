(define (append-x x xs)
  (if x
      (cons x xs)
      xs))

(define (make-symbol a b)
  (string->symbol (if (symbol? a)
                      (string-append (symbol->string a) b)
                      b)))

(define (trim? s)
  (or (eqv? s #\space)
      (eqv? s #\newline)
      (eqv? s #\tab)))

(define (op? s)
  (or (eqv? s #\+)
      (eqv? s #\-)
      (eqv? s #\*)
      (eqv? s #\/)
      (eqv? s #\^)))

(define (aren? s)
  (or (eqv? s #\()
      (eqv? s #\))))

(define (sym? x)
  (let ((ordx (char->integer x))
        (orda (char->integer #\a))
        (ordz (char->integer #\z))
        (ordb (char->integer #\A))
        (ordy (char->integer #\Z)))
    (or (and (>= ordx orda)
             (<= ordx ordz))
        (and (>= ordx ordb)
             (<= ordx ordy)))))

(define (digit? x)
  (let ((ordx (char->integer x))
        (ord0 (char->integer #\0))
        (ord9 (char->integer #\9)))
    (and (>= ordx ord0)
         (<= ordx ord9)
         (-  ordx ord0))))

(define (tokenize str)
  (define (num str)
    (define (helper xs int b digit real)
      (if (null? xs)
          (list int)
          (let* ((x (car xs))
                 (s (cdr xs))
                 (d (digit? x))
                 (n (if real (/ b 10) 10))
                 (i (and d
                         (or (and real (+ (* d b) int))
                             (+ (* int 10) d)))))
            (or (and (eq? x #\.) digit (not real) (null? s) (helper s int 0.1 digit #t))
                (and d (helper s i n #t real))
                (and (not digit) (cons #f xs))
                (and digit (cons int xs))))))
    
    (helper str 0 1 #f #f))
  
  (define (helper str token tokens)
    (if (null? str)
        (reverse (append-x token tokens))
        (let* ((s (car str))
               (t (cdr str))
               (n (num str))
               (i (car n))
               (d (cdr n)))
          (cond ((and i token) (helper d (make-symbol token (number->string i)) tokens))
                (i             (helper d #f (cons i tokens)))
                ((trim? s)     (helper t #f (append-x token tokens)))
                ((op?   s)     (helper t #f (cons (string->symbol (string s))
                                                  (append-x token tokens))))
                ((aren? s)     (helper t #f (cons (string s) tokens)))
                ((sym?  s)     (helper t (make-symbol token (string s)) tokens))
                (else          #f)))))
  
  (helper (string->list str) #f '()))

(define (parse tokens)
  (define (power tokens)
    (let ((t (car tokens))
          (s (cdr tokens)))
      (or (and (equal? t "(")
               (let ((e (expr s)))
                 (and (equal? (cadr e) ")") (cons (car e) (cddr e)))))
          (and (eq? t '-) (power s))
          (and (or (number? t) (symbol? t)) tokens))))

  (define (factor1 tokens)
    (if (eq? (car tokens) '^)
        (let ((f (factor (cdr tokens))))
          (cons ))))
  
  (define (factor tokens)
    (let* ((p (power tokens))
           (f (factor1 (cdr p))))
      (cons (cons (car p) (list (car f))) (cdr f))))
  
  (define (term tokens)
    (let* ((f (factor tokens))
           (t (term1 (cdr f))))
      (cons (cons (car f) (list (car t))) (cdr t))))
  
  (define (expr tokens)
    (let* ((t (term tokens))
           (e (expr1 (cdr t))))
      (cons (cons (car t) (list (car e))) (cdr e))))
  (expr tokens))

;; tests
(tokenize "1")
(tokenize "-a")
(tokenize "-a + b * x^2 + dy")
(tokenize "as1 + as^1232 * (1 - 5)/9")